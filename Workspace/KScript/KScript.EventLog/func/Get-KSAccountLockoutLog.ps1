function Get-KSAccountLockoutLog {
  # .SYNOPSIS
  #   Get event logs associated with account lockout.
  # .DESCRIPTION
  #   Looking for account lockout is a multi-step process:
  #
  #    1. Find all Domain Controllers
  #    2. Find values for BadPasswordTime for the user
  #    3. Create a window (based on the LogWindow parameter) prior to the most recent BadPasswordTime value.
  #    4. Search the event log on the Domain Controller holding that value.
  #    5. Search the event log on the PDCe.
  #    6. Read the log file and return the client IP responsible for generating the error.
  #    7. Attempt to lookup the host name for the client in a reverse lookup zone.
  #
  #   EventCombMT is used to search event logs. EventCombMT is shipped with this module, but may be separately downloaded as part of the Account Lockout Tools.
  #
  #   http://www.microsoft.com/en-gb/download/details.aspx?id=18465
  #
  #   Log files generated by eventcombmt are saved in a LogResults sub-directory under $WorkingDirectory. Results are read from the file and returned by this function.
  # .PARAMETER DebugLogSearcher
  #   By default, the searcher will only return information if it has something useful to display. This behaviour can be modified to return details of all search attempts by setting this parameter.
  # .PARAMETER EventcombmtPath
  #   Eventcombmt is included in the bin folder of this module. An alternative path to eventcombmt.exe may be specified if required.
  # .PARAMETER LogWindow
  #   By default Get-KSAccountLockoutLog looks at logs 30 minutes before a bad password attempt is logged in Active Directory. The timeframe may be increased or reduced using this parameter.
  #
  #   An automatic 5 minute window is added to the end of the specified time (to overlap the bad password event.
  # .PARAMETER MaximumLogAge
  #   Domain Controllers are unlikely to hold security events once they reach a certain age. This parameter prevents the script searching for events once that age is reached to reduce the script overhead.
  #
  #   By default Get-KSAccountLockoutLog will not search for badPasswordTime events older than 2 days.
  # .PARAMETER SamAccountName
  #   Find bad password times and log entries for the specified account.
  # .PARAMETER ShowAllEvents
  #   By default Get-KSAccountLockoutLog only gets details of the latest lockout event. All events matching the MaximumLogAge criteria can be returned using this parameter.
  # .PARAMETER WorkingDirectory
  #   By default, log files created by EventCombMT are stored in the current path ($PWD.Path). An alternative location may be specified using this parameter.
  # .INPUTS
  #   System.String
  #   System.TimeSpan
  # .OUTPUTS
  #   KScript.EventLog.LockoutEvent
  # .EXAMPLE
  #   Get-KSAccountLockoutLog -SamAccountName "someuser"
  # .NOTES
  #   Author: Chris Dent
  #   Team:   Core Technologies
  #
  #   Change log:
  #     03/12/2014 - Chris Dent - Force the searcher to look at the most recent BadPasswordTime event only. Allowed SamAccountName from the pipeline. Added option to only return the most recent set of results.
  #     12/11/2014 - Chris Dent - Added check for Administrative token prior to executing search. Changed method to always check PDCe for events.
  #     31/10/2014 - Chris Dent - BugFix: Unintended return value from New-Item. Limited Get-KSADDomainController property set to Name.
  #     23/09/2014 - Chris Dent - Added EventID 644.
  #     15/08/2014 - Chris Dent - Changed match to account for EventID 680 (as well as 675). Added ShowAllEvents parameter.
  #     13/08/2014 - Chris Dent - Broke pipeline (caused DS timeout error). Fixed bad field name for AuthenticatingIP.
  #     12/08/2014 - Chris Dent - BugFix: File deletion. Redesigned output. Prevented event log query executing if badPasswordTime older than MaximumLogAge.
  #     26/06/2014 - Chris Dent - Removed mandatory flag from EventCombmtPath
  #     25/06/2014 - Chris Dent - First release.

  [CmdLetBinding()]
  param(
    [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true)]
    [ValidateNotNullOrEmpty()]
    [String]$SamAccountName,

    [Switch]$ShowAllEvents,
    
    [ValidateNotNullOrEmpty()]
    [ValidateScript( { Test-Path $_ -PathType Leaf -Filter *eventcombmt.exe } )]
    [String]$EventcombmtPath = "$psscriptroot\..\bin\eventcombmt.exe",
    
    [TimeSpan]$LogWindow = (New-TimeSpan -Minutes 30),
    
    [String]$WorkingDirectory = $PWD.Path,
    
    [TimeSpan]$MaximumLogAge = (New-TimeSpan -Days 3),
    
    [Switch]$LatestOnly,
    
    [Switch]$DebugLogSearcher
  )

  begin {
    # Test for an Administrative token - required to read the security logs
    $Identity = [Security.Principal.WindowsIdentity]::GetCurrent()
    $IsAdmin = (New-Object Security.Principal.WindowsPrincipal $Identity).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
    if (-not $IsAdmin) {
      Write-Warning "Get-KSAccountLockoutLog requires an administrative token. Please run 'Start-Process PowerShell -Verb runas' then re-run the search"
      break
    }
  }
  
  process {
    # Purge the content of the LogResults folder
    if (Test-Path "$WorkingDirectory\LogResults") {
      Remove-Item "$WorkingDirectory\LogResults\*.*"
    } else {
      New-Item "$WorkingDirectory\LogResults" -Type Directory | Out-Null
    }

    Write-Verbose "$($myinvocation.InvocationName): Getting Domain Controllers"
    # Get a Domain Controller list - Target the PDCe
    $PDCe = Get-KSADFSMORoleOwner | Where-Object { $_.Role -eq 'PDCEmulator' } | ForEach-Object { $_.Owner -replace '\..+$' }
    # This may generate a timeout, a number of the DCs are too busy to properly return a complete list.
    # Temporarily hard-set to use ukwatdc01 as it is far less busy.
    $DomainControllers = Get-KSADDomainController -Properties Name -ComputerName ukwatdc01
    
    # Gather badPasswordTime information
    Write-Verbose "$($myinvocation.InvocationName): Getting badPasswordTime for $SamAccountName"
    $ADSearchResults = $DomainControllers | ForEach-Object {
      $DomainController = $_.Name

      # Get bad password time from each Domain Controller.
      Get-KSADUser -SamAccountName $SamAccountName -Properties 'samaccountname', 'displayname', 'distinguishedname', 'badpasswordtime' -ComputerName $_.Name -ErrorAction SilentlyContinue |
        Select-Object `
          SamAccountName,
          DisplayName,
          DistinguishedName,
          BadPasswordTime,
          @{n='Start';e={ ($_.BadPasswordTime - $LogWindow).ToString("MMddyyyyHHmmss") }},
          @{n='StartDateTime';e={ $_.BadPasswordTime - $LogWindow }},
          @{n='End';e={ ($_.BadPasswordTime + (New-TimeSpan -Minutes 5)).ToString("MMddyyyyHHmmss") }},
          @{n='EndDateTime';e={ $_.BadPasswordTime + (New-TimeSpan -Minutes 5) }},
          @{n='DomainController';e={ $DomainController }}
    } | Where-Object BadPasswordTime | Sort-Object BadPasswordTime -Descending

    # Each search will involve the following:
    #   1. A search against the Domain Controller recording the badPasswordTime.
    #   2. A search against the PDCe for a lockout notification (except where the two servers are the same).
    
    if ($LatestOnly) {
      $ADSearchResults = $ADSearchResults | Group-Object Start | Select-Object -First 1 | Select-Object -ExpandProperty Group
    }
    
    $ADSearchResults | Group-Object Start | ForEach-Object {
      if ($_.Group[0].StartDateTime -ge ((Get-Date) - $MaximumLogAge)) {
        $DomainControllerList = [Array]($_.Group | Select-Object -ExpandProperty DomainController)
        if ($DomainControllerList -notcontains $PDCe) {
          $DomainControllerList += $PDCe
        }
        $DomainControllerParameter = ($DomainControllerList | ForEach-Object { "/s:$_" }) -join ' '

        Write-Verbose "$($myinvocation.InvocationName): Getting logs from $DomainControllerList for $($_.Group[0].StartDateTime) to $($_.Group[0].EndDateTime)"
        
        # Execute the search against the reporting Domain Controller.
        $Command = "$EventcombmtPath $DomainControllerParameter /evt:""644 675 680"" /et:safa /log:sec /outdir:""$WorkingDirectory\LogResults"" /text:""$($_.Group[0].SamAccountName)"" /after:$($_.Group[0].Start) /before:$($_.Group[0].End) /start"
        # Execute the command
        Write-Verbose "$($myinvocation.InvocationName): Executing $Command"
        & "cmd.exe" "/c", $Command
      }
      
      $BaseLockoutRecord = $_.Group[0]
      
      Resolve-Path "$WorkingDirectory\LogResults\*-Security_LOG.txt" | ForEach-Object {
        $LogFile = $_.Path
        $LogFile -match '.+\\([^\-]+)' | Out-Null
        $DomainController = $matches[1].ToLower()
        
        Import-Csv $LogFile -Header EventID, Type, LogName, Date, User, Message |
          Select-Object `
            Message, 
            @{n='AuthenticatingClient';e={ if ($_.Message -match '(?:Source Workstation|Client Address|Caller Machine Name): (\S+)') { $matches[1] } }} |
          Group-Object AuthenticatingClient |
          ForEach-Object {
            $LockoutRecord = New-Object PSObject -Property ([Ordered]@{
              SamAccountName         = $BaseLockoutRecord.SamAccountName
              DisplayName            = $BaseLockoutRecord.DisplayName
              DistinguishedName      = $BaseLockoutRecord.DistinguishedName
              BadPasswordTime        = $BaseLockoutRecord.BadPasswordTime
              DomainController       = $DomainController
              LogEntry               = $_.Group[0].Message
              AuthenticatingIP       = $null
              AuthenticatingHostname = $null
            })
            $LockoutRecord.PSObject.TypeNames.Add("KScript.EventLog.LockoutEvent")
            
            if ([IPAddress]::TryParse($_.Name, [Ref]$null)) {
              $LockoutRecord.AuthenticatingIP = $_.Name
              $LockoutRecord.AuthenticatingHostName = try { [Net.Dns]::GetHostEntry($_.Name) | Select-Object -ExpandProperty HostName } catch { }
              $LockoutRecord.AuthenticatingHostName = "$($LockoutRecord.AuthenticatingHostName) (best guess)"
            } elseif ($_.Name) {
              $LockoutRecord.AuthenticatingHostName = $_.Name
              $LockoutRecord.AuthenticatingIP = try { [Net.Dns]::GetHostEntry($_.Name) | Select-Object -ExpandProperty AddressList | Select-Object -ExpandProperty IPAddressToString } catch { }
              $LockoutRecord.AuthenticatingIP = "$($LockoutRecord.AuthenticatingIP) (best guess)"
            }
            
            if ($LockoutRecord.LogEntry) {
              $LockoutRecord
            }
          }
      
        $FileName = (Split-Path $LogFile -Leaf) -replace '\.[^.]+$'
        $BackupPath = "$WorkingDirectory\LogResults\Backup\$FileName.$(Get-Date -Format 'yyyyMMddHHmmss').log"
        if (-not (Test-Path "$WorkingDirectory\LogResults\Backup")) {
          New-Item "$WorkingDirectory\LogResults\Backup" -ItemType Directory | Out-Null
        }
        Move-Item $LogFile -Destination $BackupPath
      }

      if ($DebugLogSearcher) {
        Write-Host
        Write-Host ((Get-Content "$WorkingDirectory\LogResults\EventCombMT.txt") -join "`n") -ForegroundColor Gray
        Write-Host
      }
    }
  }
}